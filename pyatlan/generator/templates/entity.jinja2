# SPDX-License-Identifier: Apache-2.0
# Copyright 2022 Atlan Pte. Ltd.
# Based on original code from https://github.com/apache/atlas (under Apache-2.0 license)
from __future__ import annotations

import sys
from datetime import datetime
from typing import Any, ClassVar, Dict, List, Optional, TypeVar

from pydantic import Field, StrictStr, root_validator, validator

from pyatlan.model.core import Announcement, AtlanObject, BusinessAttributes, Classification, Meaning
from pyatlan.model.enums import (
    ADLSAccessTier,
    ADLSAccountStatus,
    ADLSEncryptionTypes,
    ADLSLeaseState,
    ADLSLeaseStatus,
    ADLSObjectArchiveStatus,
    ADLSObjectType,
    ADLSPerformance,
    ADLSProvisionState,
    ADLSReplicationType,
    ADLSStorageKind,
    AnnouncementType,
    AtlanConnectorType,
    CertificateStatus,
    EntityStatus,
    IconType,
    KafkaTopicCompressionType,
    QuickSightFolderType,
    QuickSightDatasetFieldType,
    QuickSightAnalysisStatus,
    QuickSightDatasetImportMode,
    QueryUsernameStrategy,
    SourceCostUnitType,
    GoogleDatastudioAssetType,
    PowerbiEndorsement
)
from pyatlan.model.internal import AtlasServer, Internal
from pyatlan.model.structs import (
    AwsTag,
    AzureTag,
    BadgeCondition,
    ColumnValueFrequencyMap,
    DbtMetricFilter,
    GoogleLabel,
    GoogleTag,
    Histogram,
    KafkaTopicConsumption,
    PopularityInsights,
)
from pyatlan.utils import next_id

def validate_single_required_field(field_names: list[str], values: list[Any]):
    indexes = [idx for idx, value in enumerate(values) if value is not None]
    if not indexes:
        raise ValueError(
            f"One of the following parameters are required: {', '.join(field_names)}"
        )
    if len(indexes) > 1:
        names = [field_names[idx] for idx in indexes]
        raise ValueError(
            f"Only one of the following parameters are allowed: {', '.join(names)}"
        )

def validate_required_fields(field_names:list[str], values:list[Any]):
    for field_name, value in  zip(field_names, values):
        if value is None:
            raise ValueError(f"{field_name} is required")
        if isinstance(value, str) and not value.strip():
            raise ValueError(f"{field_name} cannot be blank")
{%- macro gen_properties(attribute_defs) %}
    _convience_properties: ClassVar[list[str]] = [
        {%- for attribute_def in attribute_defs %}
        "{{ attribute_def.name | to_snake_case }}",
        {%- endfor %}]
    {%- for attribute_def in attribute_defs %}
    {%- set type = attribute_def.typeName | get_type %}
    {%- set property_type %}{% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %}{% endset %}
    {%- set property_name =  attribute_def.name | to_snake_case %}
    @property
    def {{ property_name }}(self)->{{ property_type }}:
        return self.attributes.{{ property_name }}

    @{{ property_name }}.setter
    def {{ property_name }}(self, {{ property_name }}:{{ property_type }}):
        if self.attributes is None:
            self.attributes = self.Attributes()
        self.attributes.{{ property_name }} = {{ property_name }}

    {%- endfor %}
{% endmacro %}
SelfAsset = TypeVar("SelfAsset", bound="Asset")
{% for entity_def in entity_defs %}
{%- set super_classes = ['AtlanObject'] if not entity_def.super_types else entity_def.super_types -%}
class {{ entity_def.name }}({{super_classes[0]}} {%- if "Asset" in super_classes  %}, type_name='{{ entity_def.name }}'{% endif %}):
    """Description"""
{% if entity_def.name == "Referenceable" %}
    def __init__(__pydantic_self__, **data:Any)->None:
        super().__init__(**data)
        __pydantic_self__.__fields_set__.add('type_name')
{% endif %}
    def __setattr__(self, name, value):
            if name in {{ entity_def.name }}._convience_properties:
                return object.__setattr__(self, name, value)
            super().__setattr__( name, value)

    {{ gen_properties(entity_def.attribute_defs) }}

{%- if entity_def.name == "Referenceable"  %}

    class Attributes(AtlanObject):
        {%- for attribute_def in entity_def.attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {%- set default_value = "''" if attribute_def.name == "qualifiedName" else "None" %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field({{ default_value }}, description='' , alias='{{attribute_def.name}}')
        {%- endfor %}
        {%- for attribute_def in entity_def.relationship_attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='',  alias='{{attribute_def.name}}') # relationship
        {%- endfor %}

        def validate_required(self):
            pass

    attributes: '{{entity_def.name}}.Attributes' = Field(
        None,
        description='Map of attributes in the instance and their values. The specific keys of this map will vary '
                    'by type, so are described in the sub-types of this schema.\n',
    )
    business_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Map of custom metadata attributes and values defined on the entity.\n',
        alias='businessAttributes'
    )
    created_by: Optional[str] = Field(
        None,
        description='Username of the user who created the object.\n',
        example='jsmith',
    )
    create_time: Optional[int] = Field(
        None,
        description='Time (epoch) at which this object was created, in milliseconds.\n',
        example=1648852296555,
    )
    delete_handler: Optional[str] = Field(
        None,
        description="Details on the handler used for deletion of the asset.",
        example="Hard",
    )
    guid: str = Field(
        "",
        description='Unique identifier of the entity instance.\n',
        example='917ffec9-fa84-4c59-8e6c-c7b114d04be3',
    )
    is_incomplete: Optional[bool] = Field(True, description='', example=True)
    labels: Optional[List[str]] = Field(None, description='Internal use only.')
    relationship_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Map of relationships for the entity. The specific keys of this map will vary by type, '
                    'so are described in the sub-types of this schema.\n',
    )
    status: Optional[EntityStatus] = Field(
        None,
        description="Status of the entity",
        example=EntityStatus.ACTIVE
    )
    type_name: str = Field(
        None, description='Name of the type definition that defines this instance.\n'
    )
    updated_by: Optional[str] = Field(
        None,
        description='Username of the user who last assets_updated the object.\n',
        example='jsmith',
    )
    update_time: Optional[int] = Field(
        None,
        description='Time (epoch) at which this object was last assets_updated, in milliseconds.\n',
        example=1649172284333,
    )
    version: Optional[int] = Field(
        None, description='Version of this object.\n', example=2
    )
    classifications: Optional[list[Classification]] = Field(
        None, description="classifications"
    )
    classification_names: Optional[list[str]] = Field(
        None, description="The names of the classifications that exist on the asset."
    )
    display_text: Optional[str] = Field(
        None,
        description="Human-readable name of the entity..\n",
    )
    entity_status: Optional[str] = Field(
        None,
        description="Status of the entity (if this is a related entity).\n",
    )
    relationship_guid: Optional[str] = Field(
        None,
        description="Unique identifier of the relationship (when this is a related entity).\n",
    )
    relationship_status: Optional[str] = Field(
        None,
        description="Status of the relationship (when this is a related entity).\n",
    )
    relationship_type: Optional[str] = Field(
        None,
        description="Status of the relationship (when this is a related entity).\n",
    )
    meaning_names: Optional[list[str]] = Field(
        None, description="Names of terms that have been linked to this asset."
    )
    meanings: Optional[list[Meaning]] = Field(
        None, description="", alias="meanings"
    )
    custom_attributes: Optional[dict[str, Any]] = Field(None, description="", alias="customAttributes")
    scrubbed: Optional[bool] = Field(
        None, description="", alias="fields removed from results"
    )
    pending_tasks: Optional[list[str]] = Field(None)

    unique_attributes: Optional[dict[str, Any]] = Field(None)

    def validate_required(self):
        if not self.create_time or self.created_by:
            self.attributes.validate_required()

    def get_business_attributes(self, name: str) -> BusinessAttributes:
        from pyatlan.cache.custom_metadata_cache import CustomMetadataCache

        ba_id = CustomMetadataCache.get_id_for_name(name)
        if ba_id is None:
            raise ValueError(f"No business attributes with the name: {name} exist")
        for a_type in CustomMetadataCache.types_by_asset[self.type_name]:
            if (
                hasattr(a_type, "_meta_data_type_name")
                and a_type._meta_data_type_name == name
            ):
                break
        else:
            raise ValueError(
                f"Business attributes {name} are not applicable to {self.type_name}"
            )
        if ba_type := CustomMetadataCache.get_type_for_id(ba_id):
            return (
                ba_type(self.business_attributes[ba_id])
                if self.business_attributes and ba_id in self.business_attributes
                else ba_type()
            )
        else:
            raise ValueError(
                f"Business attributes {name} are not applicable to {self.type_name}"
            )

    def set_business_attribute(self, business_attributes: BusinessAttributes) -> None:
        from pyatlan.cache.custom_metadata_cache import CustomMetadataCache

        if not isinstance(business_attributes, BusinessAttributes):
            raise ValueError(
                "business_attributes must be an instance of BusinessAttributes"
            )
        if (
            type(business_attributes)
            not in CustomMetadataCache.types_by_asset[self.type_name]
        ):
            raise ValueError(
                f"Business attributes {business_attributes._meta_data_type_name} are not applicable to {self.type_name}"
            )
        ba_dict = dict(business_attributes)
        if not self.business_attributes:
            self.business_attributes = {}
        self.business_attributes[business_attributes._meta_data_type_id] = ba_dict

{%- else %}
    {%- if entity_def.name == "Asset"  %}
    _subtypes_:dict[str, type] = dict()

    def __init_subclass__(cls, type_name=None):
        cls._subtypes_[type_name or cls.__name__.lower()] = cls

    @classmethod
    def create_for_modification(
        cls: type[SelfAsset], qualified_name: str = "", name: str = ""
    ) -> SelfAsset:
        validate_required_fields(
            ["name", "qualified_name"],
            [name, qualified_name],
        )
        return cls(attributes=cls.Attributes(qualified_name=qualified_name, name=name))

    @classmethod
    def ref_by_guid(cls: type[SelfAsset], guid: str) -> SelfAsset:
        retval: SelfAsset = cls(attributes=cls.Attributes())
        retval.guid = guid
        return retval

    @classmethod
    def ref_by_qualified_name(cls: type[SelfAsset], qualified_name: str) -> SelfAsset:
        ret_value: SelfAsset = cls(
            attributes=cls.Attributes(qualified_name=qualified_name)
        )
        ret_value.unique_attributes = {"qualifiedName": qualified_name}
        return ret_value

    @classmethod
    def __get_validators__(cls):
        yield cls._convert_to_real_type_

    @classmethod
    def _convert_to_real_type_(cls, data):

        if isinstance(data, Asset):
            return data

        data_type = (
            data.get("type_name") if "type_name" in data else data.get("typeName")
        )

        if data_type is None:
            if issubclass(cls, Asset):
                return cls(**data)
            raise ValueError("Missing 'type' in Asset")

        sub = cls._subtypes_.get(data_type)
        if sub is None:
            sub = getattr(sys.modules[__name__], data_type)


        if sub is None:
            raise TypeError(f"Unsupport sub-type: {data_type}")

        return sub(**data)
    {%- endif %}
    type_name: str = Field("{{ entity_def.name }}", allow_mutation=False)

    @validator('type_name')
    def validate_type_name(cls, v):
        if v != "{{ entity_def.name }}":
            raise ValueError('must be {{ entity_def.name }}')
        return v

    {%- if entity_def.name == "Readme" %}
    @classmethod
    # @validate_arguments()
    def create(cls, asset: Asset) -> Readme:
        return Readme(
            attributes=Readme.Attributes(
                qualified_name=f"{asset.guid}/readme",
                name=f"{asset.attributes.name} Readme",
            ),
        )
    {%- endif %}
    {%- if entity_def.attribute_defs %}
    class Attributes({{super_classes[0]}}.Attributes):
        {%- for attribute_def in entity_def.attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='' , alias='{{attribute_def.name}}')
        {%- endfor %}
        {%- for attribute_def in entity_def.relationship_attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='',  alias='{{attribute_def.name}}') # relationship
        {%- endfor %}
        {%- if entity_def.name == "Asset"  %}
        def remove_description(self):
            self.description = None

        def remove_user_description(self):
            self.user_description = None

        def remove_owners(self):
            self.owner_groups = None
            self.owner_users = None

        def remove_certificate(self):
            self.certificate_status = None
            self.certificate_status_message = None

        def remove_announcement(self):
            self.announcement_message = None
            self.announcement_title = None
            self.announcement_type = None
        {%- endif  %}
        {%- if entity_def.name == "Connection"  %}
        def validate_required(self):
            if not self.name:
                raise ValueError("name is required")
            if not self.admin_roles and not self.admin_groups and not self.admin_users:
                raise ValueError(
                    "One of admin_user, admin_groups or admin_roles is required"
                )
            if not self.qualified_name:
                raise ValueError("qualified_name is required")
            if not self.category:
                raise ValueError("category is required")
            if not self.connector_name:
                raise ValueError("connector_name is required")

        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: str,
            connector_type: AtlanConnectorType,
            admin_users: Optional[list[str]] = None,
            admin_groups: Optional[list[str]] = None,
            admin_roles: Optional[list[str]] = None,
        )->{{ entity_def.name }}.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["connector_type"], [connector_type])
            if admin_users or admin_groups or admin_roles:
                return cls(
                    name=name,
                    qualified_name=connector_type.to_qualified_name(),
                    connector_name=connector_type.value,
                    category=connector_type.category.value,
                    admin_users=admin_users,
                    admin_groups=admin_groups,
                    admin_roles=admin_roles,
                )
            else:
                raise ValueError(
                    "One of admin_user, admin_groups or admin_roles is required"
                )
        {%- elif entity_def.name == "Database"  %}
        @classmethod
        # @validate_arguments()
        def create(cls, name: str, connection_qualified_name: str)->{{ entity_def.name }}.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["connection_qualified_name"], [connection_qualified_name])
            fields = connection_qualified_name.split("/")
            if len(fields) != 3:
                raise ValueError("Invalid connection_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1]) # type:ignore
            except ValueError as e:
                raise ValueError("Invalid connection_qualified_name") from e
            return Database.Attributes(
                name=name,
                connection_qualified_name=connection_qualified_name,
                qualified_name=f"{connection_qualified_name}/{name}",
                connector_name=connector_type.value,
            )
        {%-  elif entity_def.name == "Schema" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls, *, name: str, database_qualified_name: str
        ) -> Schema.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(
                ["database_qualified_name"], [database_qualified_name]
            )
            fields = database_qualified_name.split("/")
            if len(fields) != 4:
                raise ValueError("Invalid database_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError as e:
                raise ValueError("Invalid database_qualified_name") from e
            return Schema.Attributes(
                name=name,
                database_name=fields[3],
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                database_qualified_name=database_qualified_name,
                qualified_name=f"{database_qualified_name}/{name}",
                connector_name=connector_type.value,
                database=Database.ref_by_qualified_name(database_qualified_name),
            )
        {%- elif entity_def.name == "Table" or entity_def.name == "View" %}
        @classmethod
        # @validate_arguments()
        def create(cls, *, name: str, schema_qualified_name: str) -> {{ entity_def.name }}.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["schema_qualified_name"], [schema_qualified_name])
            fields = schema_qualified_name.split("/")
            if len(fields) != 5:
                raise ValueError("Invalid schema_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError as e:
                raise ValueError("Invalid schema_qualified_name") from e
            return {{  entity_def.name }}.Attributes(
                name=name,
                database_name=fields[3],
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                database_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}/{fields[3]}",
                qualified_name=f"{schema_qualified_name}/{name}",
                schema_qualified_name=schema_qualified_name,
                schema_name=fields[4],
                connector_name=connector_type.value,
                atlan_schema=Schema.ref_by_qualified_name(schema_qualified_name),
            )
        {%- elif entity_def.name == "Column" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls, *, name: str, parent_qualified_name: str, parent_type: type, order: int
        ) -> Column.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["parent_qualified_name"], [parent_qualified_name])
            fields = parent_qualified_name.split("/")
            if len(fields) != 6:
                raise ValueError("Invalid parent_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError as e:
                raise ValueError("Invalid parent_qualified_name") from e
            ret_value = Column.Attributes(
                name=name,
                qualified_name=f"{parent_qualified_name}/{name}",
                connector_name=connector_type.value,
                schema_name=fields[4],
                schema_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}/{fields[3]}/{fields[4]}",
                database_name=fields[3],
                database_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}/{fields[3]}",
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                order=order,
            )
            if parent_type == Table:
                ret_value.table_qualified_name = parent_qualified_name
                ret_value.table = Table.ref_by_qualified_name(parent_qualified_name)
            elif parent_type == View:
                ret_value.view_qualified_name = parent_qualified_name
                ret_value.view = View.ref_by_qualified_name(parent_qualified_name)
            elif parent_type == MaterialisedView:
                ret_value.view_qualified_name = parent_qualified_name
                ret_value.materialised_view = MaterialisedView.ref_by_qualified_name(
                    parent_qualified_name
                )
            else:
                raise ValueError(
                    "parent_type must be either Table, View or MaterializeView"
                )
            return ret_value

    @classmethod
    # @validate_arguments()
    def create(
        cls, *, name: str, parent_qualified_name: str, parent_type: type, order: int
    ) -> Column:
        return Column(
            attributes=Column.Attributes.create(
                name=name,
                parent_qualified_name=parent_qualified_name,
                parent_type=parent_type,
                order=order,
            )
        )
        {%- elif entity_def.name == "S3Bucket" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls, *, name: str, connection_qualified_name: str, aws_arn: str
        ) -> {{ entity_def.name }}.Attributes:
            validate_required_fields(
                ["name", "connection_qualified_name", "aws_arn"],
                [name, connection_qualified_name, aws_arn],
            )
            fields = connection_qualified_name.split("/")
            if len(fields) != 3:
                raise ValueError("Invalid connection_qualified_name")
            try:
                if fields[0].replace(" ", "") == "" or fields[2].replace(" ", "") == "":
                    raise ValueError("Invalid connection_qualified_name")
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
                if connector_type != AtlanConnectorType.S3:
                    raise ValueError("Connector type must be s3")
            except ValueError as e:
                raise ValueError("Invalid connection_qualified_name") from e
            return {{ entity_def.name }}.Attributes(
                aws_arn=aws_arn,
                name=name,
                connection_qualified_name=connection_qualified_name,
                qualified_name=f"{connection_qualified_name}/{aws_arn}",
                connector_name=connector_type.value,
            )
        {%- elif entity_def.name == "S3Object" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: str,
            connection_qualified_name: str,
            aws_arn: str,
            s3_bucket_qualified_name: Optional[str] = None,
        ) -> S3Object.Attributes:
            validate_required_fields(
                ["name", "connection_qualified_name", "aws_arn"],
                [name, connection_qualified_name, aws_arn],
            )
            fields = connection_qualified_name.split("/")
            if len(fields) != 3:
                raise ValueError("Invalid connection_qualified_name")
            try:
                if fields[0].replace(" ", "") == "" or fields[2].replace(" ", "") == "":
                    raise ValueError("Invalid connection_qualified_name")
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
                if connector_type != AtlanConnectorType.S3:
                    raise ValueError("Connector type must be s3")
            except ValueError as e:
                raise ValueError("Invalid connection_qualified_name") from e
            return S3Object.Attributes(
                aws_arn=aws_arn,
                name=name,
                connection_qualified_name=connection_qualified_name,
                qualified_name=f"{connection_qualified_name}/{aws_arn}",
                connector_name=connector_type.value,
                s3_bucket_qualified_name=s3_bucket_qualified_name,
            )
        {%- elif entity_def.name == "AtlasGlossary" %}
        @classmethod
        # @validate_arguments()
        def create(cls, *, name: StrictStr)->{{ entity_def.name }}.Attributes:
            validate_required_fields(["name"], [name])
            return AtlasGlossary.Attributes(name=name, qualified_name=next_id())
        {%- elif entity_def.name == "AtlasGlossaryCategory" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: StrictStr,
            anchor: AtlasGlossary,
            parent_category: Optional[AtlasGlossaryCategory] = None,
        ) -> AtlasGlossaryCategory.Attributes:
            validate_required_fields(["name", "anchor"], [name, anchor])
            return AtlasGlossaryCategory.Attributes(
                name=name, anchor=anchor, parent_category=parent_category, qualified_name=next_id()
            )
        {%- elif entity_def.name == "AtlasGlossaryTerm" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: StrictStr,
            anchor: Optional[AtlasGlossary] = None,
            glossary_qualified_name: Optional[StrictStr] = None,
            glossary_guid: Optional[StrictStr] = None,
            categories: Optional[list[AtlasGlossaryCategory]] = None,
        ) -> AtlasGlossaryTerm.Attributes:
            validate_required_fields(["name"], [name])
            validate_single_required_field(
                ["anchor", "glossary_qualified_name", "glossary_guid"],
                [anchor, glossary_qualified_name, glossary_guid],
            )
            if glossary_qualified_name:
                anchor = AtlasGlossary()
                anchor.unique_attributes = {"qualifiedName": glossary_qualified_name}
            if glossary_guid:
                anchor = AtlasGlossary()
                anchor.guid = glossary_guid
            return AtlasGlossaryTerm.Attributes(
                name=name,
                anchor=anchor,
                categories=categories,
                qualified_name=next_id(),
            )
        {%- endif %}
    attributes: '{{entity_def.name}}.Attributes' = Field(
        None,
        description='Map of attributes in the instance and their values. The specific keys of this map will vary by '
                    'type, so are described in the sub-types of this schema.\n',
    )
    {%-  if entity_def.name == "Connection" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: str,
        connector_type: AtlanConnectorType,
        admin_users: Optional[list[str]] = None,
        admin_groups: Optional[list[str]] = None,
        admin_roles: Optional[list[str]] = None,
    )->{{ entity_def.name }}:
        if not name:
            raise ValueError("name cannot be blank")
        validate_required_fields(["connector_type"], [connector_type])
        if admin_users or admin_groups or admin_roles:
            attr = cls.Attributes(
                name=name,
                qualified_name=connector_type.to_qualified_name(),
                connector_name=connector_type.value,
                category=connector_type.category.value,
                admin_users=admin_users,
                admin_groups=admin_groups,
                admin_roles=admin_roles,
            )
            return cls(attributes=attr)
        else:
            raise ValueError(
                "One of admin_user, admin_groups or admin_roles is required"
            )
    {%- elif entity_def.name == "Database" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str, connection_qualified_name: str)->{{ entity_def.name }}:
        if not name:
            raise ValueError("name cannot be blank")
        validate_required_fields(["connection_qualified_name"], [connection_qualified_name])
        fields = connection_qualified_name.split("/")
        if len(fields) != 3:
            raise ValueError("Invalid connection_qualified_name")
        try:
            connector_type = AtlanConnectorType(fields[1])  # type:ignore
        except ValueError as e:
            raise ValueError("Invalid connection_qualified_name") from e
        attributes = Database.Attributes(
            name=name,
            connection_qualified_name=connection_qualified_name,
            qualified_name=f"{connection_qualified_name}/{name}",
            connector_name=connector_type.value,
        )
        return cls(attributes=attributes)
    {%- elif entity_def.name == "Schema" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str, database_qualified_name: str)->{{ entity_def.name }}:
        validate_required_fields(["name", "database_qualified_name"], [name, database_qualified_name])
        attributes = Schema.Attributes.create(name=name, database_qualified_name=database_qualified_name)
        return cls(attributes=attributes)
    {%- elif entity_def.name == "Table" or entity_def.name == "View" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str, schema_qualified_name: str)->{{ entity_def.name }}:
        validate_required_fields(["name", "schema_qualified_name"], [name, schema_qualified_name])
        attributes = {{ entity_def.name }}.Attributes.create(name=name, schema_qualified_name=schema_qualified_name)
        return cls(attributes=attributes)
    {%- elif entity_def.name == "S3Bucket" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls, *, name: str, connection_qualified_name: str, aws_arn: str
    ) -> {{ entity_def.name }}:
        validate_required_fields(
            ["name", "connection_qualified_name", "aws_arn"],
            [name, connection_qualified_name, aws_arn],
        )
        attributes = {{ entity_def.name }}.Attributes.create(
            name=name, connection_qualified_name=connection_qualified_name, aws_arn=aws_arn
        )
        return cls(attributes=attributes)
    {%- elif entity_def.name == "S3Object" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: str,
        connection_qualified_name: str,
        aws_arn: str,
        s3_bucket_qualified_name: Optional[str] = None,
    ) -> S3Object:
        validate_required_fields(
            ["name", "connection_qualified_name", "aws_arn"],
            [name, connection_qualified_name, aws_arn],
        )
        attributes = S3Object.Attributes.create(
            name=name,
            connection_qualified_name=connection_qualified_name,
            aws_arn=aws_arn,
            s3_bucket_qualified_name=s3_bucket_qualified_name
        )
        return cls(attributes=attributes)
    {%- endif %}
    {% if entity_def.name.startswith("AtlasGlossary") %}
    @root_validator()
    def update_qualified_name(cls, values):
        if "attributes" in values  and values["attributes"] and not values["attributes"].qualified_name:
            values["attributes"].qualified_name = values["guid"]
        return values
    {%- if entity_def.name == "AtlasGlossary" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: StrictStr)->{{ entity_def.name }}:
        validate_required_fields(["name"], [name])
        return AtlasGlossary(attributes=AtlasGlossary.Attributes.create(name=name))
    {% elif entity_def.name == "AtlasGlossaryCategory" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: StrictStr,
        anchor: AtlasGlossary,
        parent_category: Optional[AtlasGlossaryCategory] = None,
    ) -> AtlasGlossaryCategory:
        validate_required_fields(["name", "anchor"], [name, anchor])
        return cls(
            attributes=AtlasGlossaryCategory.Attributes.create(
                name=name, anchor=anchor, parent_category=parent_category
            )
        )
    {% elif entity_def.name == "AtlasGlossaryTerm"%}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: StrictStr,
        anchor: Optional[AtlasGlossary] = None,
        glossary_qualified_name: Optional[StrictStr] = None,
        glossary_guid: Optional[StrictStr] = None,
        categories: Optional[list[AtlasGlossaryCategory]] = None,
    ) -> AtlasGlossaryTerm:
        validate_required_fields(["name"], [name])
        return cls(
            attributes=AtlasGlossaryTerm.Attributes.create(
                name=name, anchor=anchor, glossary_qualified_name=glossary_qualified_name,  glossary_guid = glossary_guid, categories=categories
            )
        )

    @classmethod
    def create_for_modification(
        cls: type[SelfAsset],
        qualified_name: str = "",
        name: str = "",
        glossary_guid: str = "",
    ) -> SelfAsset:
        validate_required_fields(
            ["name", "qualified_name", "glossary_guid"],
            [name, qualified_name, glossary_guid],
        )
        glossary = AtlasGlossary()
        glossary.guid = glossary_guid
        return cls(
            attributes=cls.Attributes(
                qualified_name=qualified_name, name=name, anchor=glossary
            )
        )
    {%- endif  %}
    {% endif %}
    {% if entity_def.name == "Asset" %}
    def has_announcement(self) -> bool:
        return bool(
            self.attributes
            and (
                self.attributes.announcement_title
                or self.attributes.announcement_type
            )
        )

    def set_announcement(self, announcement: Announcement) -> None:
        self.attributes.announcement_type = announcement.announcement_type.value
        self.attributes.announcement_title = announcement.announcement_title
        self.attributes.announcement_message = announcement.announcement_message

    def get_announcment(self) -> Optional[Announcement]:
        if self.attributes.announcement_type and self.attributes.announcement_title:
            return Announcement(
                announcement_type=AnnouncementType[
                    self.attributes.announcement_type.upper()
                ],
                announcement_title=self.attributes.announcement_title,
                announcement_message=self.attributes.announcement_message,
            )
        return None

    def remove_announcement(self):
        self.attributes.remove_announcement()

    def remove_description(self):
        self.attributes.remove_description()

    def remove_user_description(self):
        self.attributes.remove_user_description()

    def remove_owners(self):
        self.attributes.remove_owners()

    def remove_certificate(self):
        self.attributes.remove_certificate()
    {% endif %}
    {% endif %}
{%- endif %}
{% endfor %}
Referenceable.update_forward_refs()
AtlasGlossary.update_forward_refs()
{% for entity_def in entity_defs %}
{{entity_def.name}}.Attributes.update_forward_refs()
{% endfor %}
