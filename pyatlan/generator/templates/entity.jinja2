from __future__ import annotations
from typing import Optional, Dict, Any, List, Literal
from pydantic import Field, StrictStr, root_validator, validate_arguments
import sys
from datetime import datetime
from pyatlan.model.core import AtlanObject, Classification, Announcement, Meaning
from pyatlan.model.enums import CertificateStatus, EntityStatus, google_datastudio_asset_type, powerbi_endorsement, \
    IconType, AnnouncementType, SourceCostUnitType, AtlanConnectorType, ADLSEncryptionTypes, \
    ADLSPerformance, ADLSReplicationType, ADLSStorageKind, ADLSAccountStatus, ADLSProvisionState, ADLSAccessTier, \
    ADLSLeaseState, ADLSLeaseStatus, ADLSObjectType, ADLSObjectArchiveStatus
from pyatlan.utils import next_id

class Internal(AtlanObject):
    """For internal usage"""

class AtlasServer(AtlanObject):
    """For internal usage"""

{% for struct in struct_defs %}
class {{struct.name}}(AtlanObject):
    """Description"""
    class Attributes(AtlanObject):
        {%- for attribute_def in struct.attribute_defs %}
        {%- set type = attribute_def.type_name | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.is_optional %}Optional[{% endif %}{{type}}{% if attribute_def.is_optional %}]{% endif %} = Field(None, description='' , alias='{{attribute_def.name}}')
        {%- endfor %}
{% endfor %}
{% for entity_def in entity_defs %}
{%- set super_classes = ['AtlanObject'] if not entity_def.super_types else entity_def.super_types -%}
class {{ entity_def.name }}({{super_classes[0]}} {%- if "Asset" in super_classes  %}, type_name='{{ entity_def.name }}'{% endif %}):
    """Description"""
{%- if entity_def.name == "Referenceable"  %}
    class Attributes(AtlanObject):
        {%- for attribute_def in entity_def.attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {%- set default_value = "''" if attribute_def.name == "qualifiedName" else "None" %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field({{ default_value }}, description='' , alias='{{attribute_def.name}}')
        {%- endfor %}
        {%- for attribute_def in entity_def.relationship_attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='',  alias='{{attribute_def.name}}') # relationship
        {%- endfor %}

        def validate_required(self):
            pass

    attributes: '{{entity_def.name}}.Attributes' = Field(
        None,
        description='Map of attributes in the instance and their values. The specific keys of this map will vary '
                    'by type, so are described in the sub-types of this schema.\n',
    )
    business_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Map of custom metadata attributes and values defined on the entity.\n',
        alias='businessAttributes'
    )
    created_by: Optional[str] = Field(
        None,
        description='Username of the user who created the object.\n',
        example='jsmith',
    )
    create_time: Optional[int] = Field(
        None,
        description='Time (epoch) at which this object was created, in milliseconds.\n',
        example=1648852296555,
    )
    delete_handler: Optional[str] = Field(
        None,
        description="Details on the handler used for deletion of the asset.",
        example="Hard",
    )
    guid: str = Field(
        description='Unique identifier of the entity instance.\n',
        example='917ffec9-fa84-4c59-8e6c-c7b114d04be3',
        default_factory=next_id,
    )
    is_incomplete: Optional[bool] = Field(False, description='', example=False)
    labels: Optional[List[str]] = Field(None, description='Internal use only.')
    relationship_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Map of relationships for the entity. The specific keys of this map will vary by type, '
                    'so are described in the sub-types of this schema.\n',
    )
    status: Optional[EntityStatus] = Field(
        None,
        description="Status of the entity",
        example=EntityStatus.ACTIVE
    )
    type_name: str = Field(
        None, description='Name of the type definition that defines this instance.\n'
    )
    updated_by: Optional[str] = Field(
        None,
        description='Username of the user who last updated the object.\n',
        example='jsmith',
    )
    update_time: Optional[int] = Field(
        None,
        description='Time (epoch) at which this object was last updated, in milliseconds.\n',
        example=1649172284333,
    )
    version: Optional[int] = Field(
        None, description='Version of this object.\n', example=2
    )
    classifications: Optional[list[Classification]] = Field(
        None, description="classifications"
    )
    classification_names: Optional[list[str]] = Field(
        None, description="The names of the classifications that exist on the asset."
    )
    display_text: Optional[str] = Field(
        None,
        description="Human-readable name of the entity..\n",
    )
    entity_status: Optional[str] = Field(
        None,
        description="Status of the entity (if this is a related entity).\n",
    )
    relationship_guid: Optional[str] = Field(
        None,
        description="Unique identifier of the relationship (when this is a related entity).\n",
    )
    relationship_status: Optional[str] = Field(
        None,
        description="Status of the relationship (when this is a related entity).\n",
    )
    relationship_type: Optional[str] = Field(
        None,
        description="Status of the relationship (when this is a related entity).\n",
    )
    meaning_names: Optional[list[str]] = Field(
        None, description="Names of terms that have been linked to this asset."
    )
    meanings: Optional[list[Meaning]] = Field(
        None, description="", alias="meanings"
    )
    custom_attributes: Optional[dict[str, Any]] = Field(None, description="", alias="customAttributes")
    scrubbed: Optional[bool] = Field(
        None, description="", alias="fields removed from results"
    )

    def validate_required(self):
        if not self.create_time or self.created_by:
            self.attributes.validate_required()

{%- else %}
    {%- if entity_def.name == "Asset"  %}
    _subtypes_:dict[str, type] = dict()

    def __init_subclass__(cls, type_name=None):
        cls._subtypes_[type_name or cls.__name__.lower()] = cls

    @classmethod
    def __get_validators__(cls):
        yield cls._convert_to_real_type_

    @classmethod
    def _convert_to_real_type_(cls, data):

        if isinstance(data, Asset):
            return data

        data_type = (
            data.get("type_name") if "type_name" in data else data.get("typeName")
        )

        if data_type is None:
            if issubclass(cls, Asset):
                return cls(**data)
            raise ValueError("Missing 'type' in Asset")

        sub = cls._subtypes_.get(data_type)
        if sub is None:
            sub = getattr(sys.modules[__name__], data_type)


        if sub is None:
            raise TypeError(f"Unsupport sub-type: {data_type}")

        return sub(**data)
    {%- endif %}
    {%- if entity_def.attribute_defs %}
        {%- if not entity_def.sub_types %}

    type_name: Literal['{{ entity_def.name }}'] = Field("{{ entity_def.name }}")

        {%- endif %}
    class Attributes({{super_classes[0]}}.Attributes):
        {%- for attribute_def in entity_def.attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='' , alias='{{attribute_def.name}}')
        {%- endfor %}
        {%- for attribute_def in entity_def.relationship_attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='',  alias='{{attribute_def.name}}') # relationship
        {%- endfor %}
        {%- if entity_def.name == "Asset"  %}
        def remove_description(self):
            self.description = None

        def remove_user_description(self):
            self.user_description = None

        def remove_owners(self):
            self.owner_groups = None
            self.owner_users = None

        def remove_certificate(self):
            self.certificate_status = None
            self.certificate_status_message = None

        def remove_announcement(self):
            self.announcement_message = None
            self.announcement_title = None
            self.announcement_type = None
        {%- endif  %}
        {%- if entity_def.name == "Connection"  %}
        def validate_required(self):
            if self.name:
                if self.admin_roles or self.admin_groups or self.admin_users:
                    if self.qualified_name:
                        if self.category:
                            if not self.connector_name:
                                raise ValueError("connector_name is required")
                        else:
                            raise ValueError("category is required")
                    else:
                        raise ValueError("qualified_name is required")
                else:
                    raise ValueError(
                        "One of admin_user, admin_groups or admin_roles is required"
                    )
            else:
                raise ValueError("name is required")

        @classmethod
        @validate_arguments()
        def create(
            cls,
            name: str,
            connector_type: AtlanConnectorType,
            admin_users: Optional[list[str]] = None,
            admin_groups: Optional[list[str]] = None,
            admin_roles: Optional[list[str]] = None,
        ):
            if not name:
                raise ValueError("name cannot be blank")
            if admin_users or admin_groups or admin_roles:
                return cls(
                    name=name,
                    qualified_name=connector_type.to_qualified_name(),
                    connector_name=connector_type.value,
                    category=connector_type.category.value,
                    admin_users=admin_users,
                    admin_groups=admin_groups,
                    admin_roles=admin_roles,
                )
            else:
                raise ValueError(
                    "One of admin_user, admin_groups or admin_roles is required"
                )
        {%- elif entity_def.name == "Database"  %}
        @classmethod
        @validate_arguments()
        def create(cls, name: str, connection_qualified_name: str):
            if not name:
                raise ValueError("name cannot be blank")
            fields = connection_qualified_name.split("/")
            if len(fields) != 3:
                raise ValueError("Invalid connection_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1]) # type:ignore
            except ValueError:
                raise ValueError("Invalid connection_qualified_name")
            return Database.Attributes(
                name=name,
                connection_qualified_name=connection_qualified_name,
                qualified_name=f"{connection_qualified_name}/{name}",
                connector_name=connector_type.value,
            )
        {%-  elif entity_def.name == "Schema" %}
        @classmethod
        @validate_arguments()
        def create(cls, name: str, database_qualified_name: str):
            if not name:
                raise ValueError("name cannot be blank")
            fields = database_qualified_name.split("/")
            if len(fields) != 4:
                raise ValueError("Invalid database_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError:
                raise ValueError("Invalid database_qualified_name")
            return Schema.Attributes(
                name=name,
                database_name=fields[3],
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                database_qualified_name=database_qualified_name,
                qualified_name=f"{database_qualified_name}/{name}",
                connector_name=connector_type.value,
            )
        {%- elif entity_def.name == "Table" or entity_def.name == "View" %}
        @classmethod
        @validate_arguments()
        def create(cls, name: str, schema_qualified_name: str):
            if not name:
                raise ValueError("name cannot be blank")
            fields = schema_qualified_name.split("/")
            if len(fields) != 5:
                raise ValueError("Invalid schema_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError:
                raise ValueError("Invalid schema_qualified_name")
            return {{  entity_def.name }}.Attributes(
                name=name,
                database_name=fields[3],
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                database_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}/{fields[3]}",
                qualified_name=f"{schema_qualified_name}/{name}",
                schema_qualified_name=schema_qualified_name,
                schema_name=fields[4],
                connector_name=connector_type.value,
            )
        {%- elif entity_def.name == "AtlasGlossary" %}
        @classmethod
        @validate_arguments()
        def create(cls, name: StrictStr):
            return AtlasGlossary.Attributes(name=name)
        {%- elif entity_def.name == "AtlasGlossaryCategory" or entity_def.name == "AtlasGlossaryTerm" %}
        @classmethod
        @validate_arguments()
        def create(cls, name: StrictStr, anchor: AtlasGlossary):
            return {{ entity_def.name }}.Attributes(name=name, anchor=anchor)
        {%- endif %}
    attributes: '{{entity_def.name}}.Attributes' = Field(
        None,
        description='Map of attributes in the instance and their values. The specific keys of this map will vary by '
                    'type, so are described in the sub-types of this schema.\n',
    )
    {%-  if entity_def.name == "Connection" %}
    @classmethod
    @validate_arguments()
    def create(
        cls,
        name: str,
        connector_type: AtlanConnectorType,
        admin_users: Optional[list[str]] = None,
        admin_groups: Optional[list[str]] = None,
        admin_roles: Optional[list[str]] = None,
    ):
        if not name:
            raise ValueError("name cannot be blank")
        if admin_users or admin_groups or admin_roles:
            attr = cls.Attributes(
                name=name,
                qualified_name=connector_type.to_qualified_name(),
                connector_name=connector_type.value,
                category=connector_type.category.value,
                admin_users=admin_users,
                admin_groups=admin_groups,
                admin_roles=admin_roles,
            )
            return cls(attributes=attr)
        else:
            raise ValueError(
                "One of admin_user, admin_groups or admin_roles is required"
            )
    {%- elif entity_def.name == "Database" %}
    @classmethod
    @validate_arguments()
    def create(cls, name: str, connection_qualified_name: str):
        if not name:
            raise ValueError("name cannot be blank")
        fields = connection_qualified_name.split("/")
        if len(fields) != 3:
            raise ValueError("Invalid connection_qualified_name")
        try:
            connector_type = AtlanConnectorType(fields[1])  # type:ignore
        except ValueError:
            raise ValueError("Invalid connection_qualified_name")
        attributes = Database.Attributes(
            name=name,
            connection_qualified_name=connection_qualified_name,
            qualified_name=f"{connection_qualified_name}/{name}",
            connector_name=connector_type.value,
        )
        return cls(attributes=attributes)
    {%- elif entity_def.name == "Schema" %}
    @classmethod
    @validate_arguments()
    def create(cls, name: str, database_qualified_name: str):
        attributes = Schema.Attributes.create(name, database_qualified_name)
        return cls(attributes=attributes)
    {%- elif entity_def.name == "Table" or entity_def.name == "View" %}
    @classmethod
    @validate_arguments()
    def create(cls, name: str, schema_qualified_name: str):
        attributes = {{ entity_def.name }}.Attributes.create(name, schema_qualified_name)
        return cls(attributes=attributes)
    {%- endif %}
    {% if entity_def.name.startswith("AtlasGlossary") %}
    @root_validator()
    def update_qualified_name(cls, values):
        if "attributes" in values  and values["attributes"] and not values["attributes"].qualified_name:
            values["attributes"].qualified_name = values["guid"]
        return values

    {%- if entity_def.name == "AtlasGlossary" %}
    @classmethod
    @validate_arguments()
    def create(cls, name: StrictStr):
        return AtlasGlossary(attributes=AtlasGlossary.Attributes.create(name))
    {% elif entity_def.name == "AtlasGlossaryCategory" or entity_def.name == "AtlasGlossaryTerm"%}
    @classmethod
    @validate_arguments()
    def create(cls, name: StrictStr, anchor: AtlasGlossary):
        return cls(attributes={{ entity_def.name }}.Attributes.create(name=name, anchor=anchor))
    {%- endif  %}
    {% endif %}
    {% if entity_def.name == "Asset" %}
    def has_announcement(self) -> bool:
        if self.attributes and (
            self.attributes.announcement_title or self.attributes.announcement_type
        ):
            return True
        else:
            return False

    def set_announcement(self, announcement: Announcement) -> None:
        self.attributes.announcement_type = announcement.announcement_type.value
        self.attributes.announcement_title = announcement.announcement_title
        self.attributes.announcement_message = announcement.announcement_message

    def get_announcment(self) -> Optional[Announcement]:
        if self.attributes.announcement_type and self.attributes.announcement_title:
            return Announcement(
                announcement_type=AnnouncementType[
                    self.attributes.announcement_type.upper()
                ],
                announcement_title=self.attributes.announcement_title,
                announcement_message=self.attributes.announcement_message,
            )
        return None

    def remove_announcement(self):
        self.attributes.remove_announcement()

    def remove_description(self):
        self.attributes.remove_description()

    def remove_user_description(self):
        self.attributes.remove_user_description()

    def remove_owners(self):
        self.attributes.remove_owners()

    def remove_certificate(self):
        self.attributes.remove_certificate()
    {% endif %}
    {% endif %}
{%- endif %}
{% endfor %}
class MutatedEntities(AtlanObject):
    CREATE: Optional[list[Asset]] = Field(
        None,
        description="Assets that were created. The detailed properties of the returned asset will vary based on the "
        "type of asset, but listed in the example are the common set of properties across assets.",
        alias="CREATE",
    )
    UPDATE: Optional[list[Asset]] = Field(
        None,
        description="Assets that were updated. The detailed properties of the returned asset will vary based on the "
        "type of asset, but listed in the example are the common set of properties across assets.",
        alias="UPDATE",
    )
    DELETE: Optional[list[Asset]] = Field(
        None,
        description="Assets that were deleted. The detailed properties of the returned asset will vary based on the "
        "type of asset, but listed in the example are the common set of properties across assets.",
        alias="DELETE",
    )


class AssetMutationResponse(AtlanObject):
    guid_assignments: dict[str, Any] = Field(
        None, description="Map of assigned unique identifiers for the changed assets."
    )
    mutated_entities: Optional[MutatedEntities] = Field(
        None, description="Assets that were changed."
    )
Referenceable.update_forward_refs()
AtlasGlossary.update_forward_refs()
{% for entity_def in entity_defs %}
{{entity_def.name}}.Attributes.update_forward_refs()
{% endfor %}
